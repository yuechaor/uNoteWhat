<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker笔记 | uNoteWhat</title>
    <meta name="description" content="My Learning Notes, Flutter坑，Dart坑，坑，issue，errors">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/uNoteWhat/img/avatar.jpeg">
    <link rel="preload" href="/uNoteWhat/assets/css/0.styles.8334e0c5.css" as="style"><link rel="preload" href="/uNoteWhat/assets/js/app.58bd65f3.js" as="script"><link rel="preload" href="/uNoteWhat/assets/js/6.9f100392.js" as="script"><link rel="preload" href="/uNoteWhat/assets/js/18.76d03fcd.js" as="script"><link rel="prefetch" href="/uNoteWhat/assets/js/1.62bc2bb2.js"><link rel="prefetch" href="/uNoteWhat/assets/js/10.fbe89c91.js"><link rel="prefetch" href="/uNoteWhat/assets/js/11.eb4ab1a8.js"><link rel="prefetch" href="/uNoteWhat/assets/js/12.42ba0867.js"><link rel="prefetch" href="/uNoteWhat/assets/js/13.cc34cef8.js"><link rel="prefetch" href="/uNoteWhat/assets/js/14.b9d181ff.js"><link rel="prefetch" href="/uNoteWhat/assets/js/15.92f21756.js"><link rel="prefetch" href="/uNoteWhat/assets/js/16.5ddf09c8.js"><link rel="prefetch" href="/uNoteWhat/assets/js/17.a4ab07f8.js"><link rel="prefetch" href="/uNoteWhat/assets/js/19.b9e0498d.js"><link rel="prefetch" href="/uNoteWhat/assets/js/20.86889de2.js"><link rel="prefetch" href="/uNoteWhat/assets/js/21.ff9c30ad.js"><link rel="prefetch" href="/uNoteWhat/assets/js/22.f6650327.js"><link rel="prefetch" href="/uNoteWhat/assets/js/23.61db549f.js"><link rel="prefetch" href="/uNoteWhat/assets/js/24.7fdb55c5.js"><link rel="prefetch" href="/uNoteWhat/assets/js/25.e3c7b64b.js"><link rel="prefetch" href="/uNoteWhat/assets/js/26.134168ed.js"><link rel="prefetch" href="/uNoteWhat/assets/js/27.040487f4.js"><link rel="prefetch" href="/uNoteWhat/assets/js/28.e76763ba.js"><link rel="prefetch" href="/uNoteWhat/assets/js/3.6bdddad3.js"><link rel="prefetch" href="/uNoteWhat/assets/js/4.10d92757.js"><link rel="prefetch" href="/uNoteWhat/assets/js/5.6d1e94d9.js"><link rel="prefetch" href="/uNoteWhat/assets/js/7.38452614.js"><link rel="prefetch" href="/uNoteWhat/assets/js/8.5c116278.js"><link rel="prefetch" href="/uNoteWhat/assets/js/9.a6a30b66.js">
    <link rel="stylesheet" href="/uNoteWhat/assets/css/0.styles.8334e0c5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" data-v-7a046aea><div data-v-e4145d0a data-v-7a046aea><nav class="navbar" data-v-e4145d0a><div class="container" data-v-e4145d0a><a href="/uNoteWhat/" class="router-link-active" data-v-e4145d0a><span class="navbar-site-name" data-v-e4145d0a>
          uNoteWhat
        </span></a> <div class="navbar-toggler" data-v-e4145d0a><svg class="icon" style="font-size:1.2em;" data-v-e4145d0a data-v-e4145d0a><title data-v-e4145d0a data-v-e4145d0a>menu</title><use xlink:href="#icon-menu" data-v-e4145d0a data-v-e4145d0a></use></svg></div> <div class="navbar-links" data-v-e4145d0a><a href="/uNoteWhat/" class="navbar-link" data-v-e4145d0a>
            Home
          </a><a href="/uNoteWhat/posts/" class="navbar-link router-link-active" data-v-e4145d0a>
            Notes
          </a><a href="/uNoteWhat/about/" class="navbar-link" data-v-e4145d0a>
            About
          </a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-e4145d0a></div></div> <div class="banner" data-v-98d6aa8c data-v-7a046aea data-v-7a046aea><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-7a046aea>
          Docker笔记
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-4dd605a1 data-v-4dd605a1><main class="main" data-v-4dd605a1><div class="post" data-v-4dd605a1 data-v-4dd605a1><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      createdAt : 2019-08-15
    </span> <span class="update-date" data-v-4e23451f>
      updatedAt : 2019-08-15
    </span></section> <section class="post-links" data-v-4e23451f><a href="/uNoteWhat/posts/2019/07/21/_78kengs.html" class="post-link" data-v-4e23451f>
      prevNote : 坑7坑8
    </a> <a href="/uNoteWhat/posts/2019/08/15/docker-advance.html" class="post-link" data-v-4e23451f>
      nextNote : Docker高级笔记
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><p>docker 命令</p> <h2 id="镜像和容器"><a href="#镜像和容器" class="header-anchor">#</a> 镜像和容器</h2> <p>容器是镜像的一个实例。 容器是用镜像创建的运行实例。它可以被启用，开始，停止，删除，每个容器都是相互隔离的，保证平台的安全。
我们可以把容器看成一个简易版的linux环境，包括root用户权限，进程空间，用户空间和网络空间，还有运行在其中的应用程序。</p> <h2 id="仓库repository"><a href="#仓库repository" class="header-anchor">#</a> 仓库repository</h2> <p>仓库是集中<strong>存放镜像</strong>文件的场所。</p> <p>仓库和仓库注册服务器(Registry)是有区别的，仓库注册服务器上往往有多个仓库，每个仓库又还有多个镜像，每个镜像又有不同的tag。</p> <p>仓库分为公开和私有</p> <p>公开的 docker hub 阿里云，网易云。</p> <h2 id="镜像，容器，仓库-相互关系"><a href="#镜像，容器，仓库-相互关系" class="header-anchor">#</a> 镜像，容器，仓库 相互关系</h2> <p>Docker 本身是一个容器运行载体或称之为管理引擎。</p> <p>我们把打包好的应用程序和环境配置依赖形成一个可交付的运行环境，这个打包好的运行环境就类似一个image镜像文件。</p> <p>只有通过这个镜像文件才能生成docker容器，image文件可以看做是容器的模板，docker根据image文件生成一个容器实例或者多个实例。</p> <p>image文件生成的容器实例，本身也是一个文件，称为镜像文件。</p> <p>仓库可以用来存放镜像，需要的时候直接拉取。</p> <h2 id="docker底层原理"><a href="#docker底层原理" class="header-anchor">#</a> docker底层原理</h2> <h3 id="docker是怎么工作的"><a href="#docker是怎么工作的" class="header-anchor">#</a> docker是怎么工作的</h3> <p>docker 是一个CS结构的系统，docker守护进程运行在宿主机上（在执行service docker start或者systemctl start docker之后），然后通过socket连接从客户端访问，守护进程从客户端接收命令并管理主机上的容器，比如接收run命令etc 来运行容器等。</p> <h3 id="为什么docker-比-vm-快"><a href="#为什么docker-比-vm-快" class="header-anchor">#</a> 为什么docker 比 vm 快</h3> <ol><li>docker比虚拟机有更少的抽象层，不需要hypervisor来实现硬件资源虚拟化，运行在docker中的容器实例直接使用的是实际物理机的硬件资源。因此在cpu、内存利用率上 docker在效率上更有优势。</li> <li>docker利用的是宿主机的内核，而不需要Guest OS。因此，当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核这个比较费时费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，这个新建过程是分钟级别的，而docker由于直接利用宿主机的操作系统，则省略了这个过程，只需要几秒钟的时间。</li></ol> <h3 id="docker-安装以及阿里云镜像加速配置"><a href="#docker-安装以及阿里云镜像加速配置" class="header-anchor">#</a> docker 安装以及阿里云镜像加速配置</h3> <div class="language- extra-class"><pre><code>- 根据官网，根据不同系统版本来安装
- 加速配置可参考阿里云或以下视频
视频12：00处 [https://www.bilibili.com/video/av59639711/?p=9]
</code></pre></div><h2 id="一般命令"><a href="#一般命令" class="header-anchor">#</a> 一般命令</h2> <h3 id="帮助命令"><a href="#帮助命令" class="header-anchor">#</a> 帮助命令</h3> <div class="language- extra-class"><pre><code>- docker version
- docker info
- docker --help 
</code></pre></div><h3 id="镜像命令"><a href="#镜像命令" class="header-anchor">#</a> 镜像命令</h3> <p>-docker images 列出所有镜像
- a 列出全部镜像 <strong>含中间镜像层</strong>
- q 只显示全部镜像的id
- qa 两者结合 返回ID
- --digests 显示摘要信息
- --no-trunc 显示完整的id 没有截取显示</p> <ul><li>docker search xxxx
<ul><li>-s 30 根据星数超过30来筛选</li> <li>--no-trunc 显示完整的description</li> <li>--automated 只列出自动构建类型的镜像</li> <li>三个可以结合使用</li></ul></li> <li>docker pull xxx
<ul><li>docker pull xxx : 自定义tag名字</li> <li>如果不带tag制定特定版本，默认就是latest的版本</li></ul></li> <li>docker rmi xxxx ：TAG
<ul><li>如果没有标识tag版本，默认删除最新的latest</li> <li>-f 镜像名</li> <li>-f 删除多个 镜像1：TAG 镜像2：TAG 镜像名中间加空格</li> <li>删除全部 docker rmi -f $(docker images -qa)</li></ul></li></ul> <h3 id="容器命令"><a href="#容器命令" class="header-anchor">#</a> 容器命令</h3> <ul><li><p>新建一个容器实例并启动该容器</p> <ul><li>docker run [options] <strong>IMAGE</strong>[COMMAND][ARG...]</li> <li>options说明
<ul><li>有些是一个减号，有些是两个减号</li></ul></li> <li>--name=&quot;容器新名字&quot;:为容器指定一个名称</li> <li>-d：后台运行容器，并返回容器id，即启动守护式容器；</li> <li>-i: 以交互模式运行容器，通常与-t一起使用;</li> <li>-t: 为容器重新分配一个伪输入终端，通常与-i一起使用; 例如： docker run -it IMAGEid</li> <li>-P： 大P是随机分配端口映射;</li> <li>-p：指定端口映射，有以下四种格式
<ul><li>ip:hostPort:containerPort</li> <li>ip::containerPort</li> <li>hostPort:containerPort</li> <li>containerPort</li></ul></li></ul></li> <li><p>列出当前所有<strong>正在运行</strong>的容器</p> <ul><li>docker ps  （Process Status）
<ul><li>options说明
<ul><li>-a: 列出当前所有正在运行的容器+历史上运行过的</li> <li>-l:显示最近创建的容器 last</li> <li>-n: 显示最近n个创建的容器 例如 docker ps -n 3 列出上三次运行过的容器</li> <li>-q: 静默模式，只显示容器ID quiet。例如 docker ps -lq</li> <li>--no-trunc: 不截断输出</li></ul></li></ul></li></ul></li> <li><p>退出容器</p> <ul><li>两种方式
<ul><li>exit 容器停止退出</li> <li>ctrl+p+q 容器不停止退出</li></ul></li></ul></li> <li><p>启动容器</p> <ul><li>docker start 容器ID或者容器名</li></ul></li> <li><p>重启容器</p> <ul><li>docker restart 容器ID或者容器名</li></ul></li> <li><p>缓慢停止容器</p> <ul><li>docker stop 容器ID或者容器名</li></ul></li> <li><p>强制停止容器</p> <ul><li>docker kill 容器ID或者容器名</li></ul></li> <li><p>删除已停止的容器</p> <ul><li>删除在缓存中已停止的容器</li> <li>docker rm 容器ID或者容器名
<ul><li>可加 -f</li></ul></li> <li>一次性删除多个容器
<ul><li>docker rm -f $(docker ps -aq)</li> <li>docker ps -aq | xargs docker rm
<ul><li>xargs 会提取 | 前面的命令的结果 作为参数</li></ul></li></ul></li></ul></li></ul> <p><strong>重点</strong></p> <ol><li>启动守护式容器
<ul><li>docker run -d 容器名
<ul><li>docker ps 并不会显示这个daemon容器，显示容器已经退出了</li> <li>原因：这是docker的机制，很重要的说明的一点，docker容器后台运行，就必须有一个前台进程来持续调用这个容器，容器运行的命令<strong>如果不是那些一直挂起的命令</strong>，比如运行top，tail，就是会自动退出的。</li> <li>这个是docker的机制问题，比如你的web容器，我们以nginx为例，正常情况下，我们配置启动服务只需要启动响应的service即可。例如service nginx start，</li> <li>但是这样做，nginx为后台进程模式运行，就导致docker前台没有运行的应用，这样容器后台启动后，会立即自杀因为它觉得它没事可做了。</li> <li>所以，最佳的解决方案是，将你要运行的程序以前台进程的形式运行。</li> <li>使用命令是程序在后台保持运行</li> <li></li></ul></li></ul> <div class="language- extra-class"><pre class="language-text"><code>docker run -d centos /bin/sh -c &quot;while true; do echo hello world!; sleep 2; done&quot;
</code></pre></div></li> <li>查看容器日志
<ul><li>docker logs -f -t -tail 容器ID
<ul><li>-t 加入时间戳</li> <li>-f 跟随最新的日志打印</li> <li>-tail 3 加数字 显示最后多少条</li></ul></li></ul></li> <li>查看容器运行的进程
<ul><li>docker top 容器ID</li></ul></li> <li>查看容器内部的细节
<ul><li>docker inspect 容器ID
<ul><li>返回当前容器的结构细节</li> <li>以json的形式</li></ul></li></ul></li> <li>再次进入正在运行的容器并以命令行交互
<ul><li>attach 和 exec 区别：
<ul><li>docker exec -it <strong>ID</strong> 再加执行命令
<ul><li>可以不进入容器，但在容器中打开终端并执行命令和启动进程。</li> <li>例如：docker exec -it xxxx ls -l /tmp
<ul><li>结果是直接列出tmp文件夹信息，<strong>但是并不进入容器</strong></li> <li>docker exec -it xxxx /bin/bash
<ul><li>结果跟 docker attach xxx 效果一样</li></ul></li></ul></li></ul></li> <li>docker attach <strong>ID</strong> <ul><li>直接进去容器并启动命令终端，不涉及执行新的命令和进程。</li></ul></li></ul></li></ul></li> <li>从容器内拷贝文件到主机上
<ul><li>从集装箱容器内里面拷贝数据到宿主机</li> <li>docker cp ID:要拷贝的路径 目的宿主机路径</li> <li>docker cp ID:/tmp/yum.log /root</li></ul></li></ol> <h2 id="docker-镜像"><a href="#docker-镜像" class="header-anchor">#</a> docker 镜像</h2> <ol><li>是什么：
<ul><li>镜像是一种轻量级、可执行的独立软件包，用来<strong>打包软件运行环境和基于运行环境开发的软件</strong>，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</li> <li>UnionFS 联合文件系统
<ul><li>是一种分层的、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，<strong>它是docker镜像的基础</strong> 镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。
<ul><li>特性：
<ul><li>一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</li></ul></li></ul></li></ul></li> <li>Docker 镜像加载原理
<ul><li>docker的镜像实际上是由一层层的文件系统组成，这种层级的文件系统就是UnionFS</li> <li>bootfs boot file system 主要包含bootloader和kernel。
<ul><li>bootloader的作用是引导加载kernel，linux刚启动时会加载bootfs文件系统，在docker镜像的最底层bootfs。这一层与我们典型的linux\unix系统是一样的，包含boot加载器和内核。 当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</li> <li>rootfs root file system， 在bootfs之上，包含的就是典型linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，centos等。</li> <li>为什么docker里面的linux镜像很小？</li> <li>因为对于一个精简的OS,rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了。因为底层直接用host的kernel，自己只需要提供rootfs就可以了。 而对于bootfs，不同linux发行版可以公用bootfs，只有rootfs会有差别。</li></ul></li></ul></li> <li>分层的镜像
<ul><li>每个镜像都是分层的，在pull的过程中可以看到是一层层的在下载。</li></ul></li> <li>为什么docker镜像要采用这种分层结构呢
<ul><li>最大的好处就是--可以共用资源，节省资源</li> <li>比如，很多镜像都是从相同的base镜像构建而来的，那么host只需要在磁盘上保存一份base镜像，同时内存中也只需要加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享。</li></ul></li></ul></li> <li>特点</li></ol> <ul><li>Docker镜像都是只读的</li> <li>当容器启动时，一个新的可写层被加载到镜像的顶部</li> <li>这一层通常被称作为 <strong>容器层</strong>，容器层之下的都叫 <strong>镜像层</strong></li></ul> <ol start="3"><li>docker 镜像commit操作补充
<ul><li>docker commit 提交容器副本使之成为一个镜像，我们在自定义配置容器之后，为方便使用可以做成镜像，以备下次使用。</li> <li>docker commit -m=&quot;描述信息&quot; -a=&quot;author&quot; 容器ID 新建目标镜像名称：[Tags]标签名
<ul><li>docker commit -m=&quot;updates&quot; -a=&quot;ryc&quot; xxxxx newVersion:v_1</li></ul></li> <li></li></ul></li></ol> <h2 id="docker-容器数据卷"><a href="#docker-容器数据卷" class="header-anchor">#</a> Docker 容器数据卷</h2> <ol><li>是什么
<ul><li>目的是将容器运行产生的数据持久化保存下来</li> <li>希望容器之间有可能共享数据</li> <li>docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然就没有了。</li> <li>为了能保存数据在docker中，我们使用卷</li> <li>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过unionFS提供一些用于持续存储或共享数据的特性</li> <li>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会再容器删除时删除其挂载的数据卷</li> <li>特点
<ul><li>数据卷可在容器之间共享或重用数据</li> <li>卷中的更改可以直接生效</li> <li>数据卷中的更改不会包含在镜像的更新中</li> <li>数据卷的生命周期一直持续到没有容器使用它为止。</li></ul></li></ul></li> <li>能干嘛
<ul><li>容器的持久化</li> <li>容器间继承+共享数据</li></ul></li></ol> <ul><li></li></ul> <ol start="3"><li><p>数据卷实际操作
添加数据卷有两种方式：直接命令添加 &amp;&amp; DockerFile添加</p> <ol><li>直接命令添加</li></ol> <blockquote><p>docker run -it -v /宿主机绝对路径目录:/容器内目录 镜像名
docker run -it -v /myDataVolume:/dataVolumeContainer xxxx</p></blockquote> <ul><li>查看数据卷是否挂载成功</li></ul> <blockquote><p>docker inpect 查看binds</p></blockquote> <ul><li>容器和宿主机直接数据共享
<ul><li>myDataVolum 和 dataVolumeContainer 文件夹现已经成为共享文件夹了，在一个中增减改删，另外一个也会同步。</li></ul></li> <li>容器停止退出后，主机修改后数据是否同步
<ul><li>答案是完全同步。</li></ul></li> <li>命令（带权限）增改权限</li></ul> <blockquote><p>docker run -it -v /myDataVolume:/dataVolumeContainer:ro xxxx
<strong>ro:</strong> read only 只允许主机单向修改，容器端是ro</p></blockquote> <blockquote><p><strong>rw:</strong> read write</p></blockquote> <ol start="2"><li>dockerFile 添加</li></ol> <ul><li><p>根目录下新建mydocker文件夹并进入</p></li> <li><p>可在dockerFile中使用<strong>VOLUME</strong>指令来给镜像添加一个或多个数据卷</p></li> <li><p>file构建</p> <div class="language- extra-class"><pre class="language-text"><code># volume test
FROM centos
VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]
CMD echo &quot;finished, -------success&quot;
CMD /bin/bash
</code></pre></div></li> <li><p>build后生成镜像</p> <ul><li><blockquote><p>docker build -f /myDocker/Dockerfile -t xxx/centos .</p></blockquote></li> <li>获得一个新镜像 xxx/centos</li></ul></li> <li><p>run容器</p></li> <li><p>通过上述步骤，容器内的卷目录地址已经知道对应的主机目录地址哪</p> <ul><li>宿主机会随机生成对应的目录</li> <li>可以通过docker inspect来查看</li></ul></li> <li><p>主机对应默认地址</p></li></ul></li> <li><p>数据卷容器</p></li></ol> <ul><li>是什么
<ul><li>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器</li> <li>总体介绍
<ul><li>以上一步新建的镜像xxx/centos为模板并运行三个容器 dc1、dc2、dc3</li> <li>这三个模板由于都继承于xxx/centos,所以都已经具有容器卷dataVolumeContainer1、dataVolumeContainer2</li> <li>以这三个容器为基本来判断一下容器间传递共享(--volumes-from)
<ul><li><p>先启动一个父容器dc1，并在dataVolumeContainer2中新增内容hello.txt</p> <ul><li><blockquote><p>docker run -it --name dc1 xxx/centos</p></blockquote></li> <li>进入dataVolumeContainer2中新建hello.txt文件</li> <li><blockquote><p>touch hello.txt</p></blockquote></li></ul></li> <li><p>使用命令--volumes-from创建dc2、dc3</p></li></ul> <blockquote><p>docker run -it --name dc2 --volumes-from dc1 xxx/centos
docker run -it --name dc3 --volumes-from dc1 xxx/centos</p></blockquote> <ul><li>这样dc2 和dc3 都继承于dc1 所以他们的dataVolumeContainer2目录中都会有hello.txt文件</li> <li><strong>在子类中添加、删除新文件 父类和其他子类也会同步</strong>，父到子，子到父都可以同步</li> <li>删除dc1，dc2修改后dc3是否可以访问？
<ul><li>删除父类容器dc1，dc2和dc3中的数据也不会受到影响。</li></ul></li> <li>即使删除父类容器dc1了，dc2和dc3中的数据也可以同步</li> <li><strong>总结：</strong> 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。直到所有xxx/centos容器死绝为止</li></ul></li></ul></li></ul></li></ul> <h2 id="dockerfile-解析"><a href="#dockerfile-解析" class="header-anchor">#</a> dockerfile 解析</h2> <ol><li>思考并回顾一下，用dockerfile写容器卷的主流步骤有哪些？
<ol><li>手动编写一个dockerfile，按照语义规范来写</li> <li>有了这个文件后，用了docker build命令执行 生成一个自定义的镜像</li> <li>run 使用该镜像来直接生成容器，并使用--volumes-from来继承父类容器的共享目录</li></ol></li> <li>是什么
<ol><li>dockerfile是用来构建docker镜像的构建文件，是由一系列命令和参数构成的脚本
<ol><li>其实就是通过自定义一个脚本文件来构建docker镜像。</li></ol></li> <li>构建三步骤
<ol><li>编写dockerfile</li> <li>docker build</li> <li>docker run</li></ol></li> <li>文件什么样子？
<ol><li>可以去hub.docker 查看</li></ol></li></ol></li> <li>dockerfile构建过程解析
<ol><li>dockerfile内容基础知识
<ol><li>每条保留字指令都必须为大写字母，且后面要跟随至少一个参数</li> <li>指令按照从上到下，顺序执行</li> <li>#表示注释</li> <li>每条指令都会创建一个新的镜像层，并对镜像进行提交（花卷包裹理论）</li></ol></li> <li>docker 执行dockerfile的大致流程
<ol><li>docker从基础镜像运行一个容器，一定要有一个基础镜像</li> <li>执行一条指令并对容器做出修改</li> <li>执行类似docker commit的操作提交一个新的镜像层</li> <li>docker再基于刚提交的镜像运行一个新的容器，层层包裹。</li> <li>执行dockerfile的下一条指令，并循环到所有执行执行完成。</li></ol></li> <li>小总结：
<ol><li>从应用软件的角度来看，dockerfile、docker镜像、docker容器分别代表软件的三个不同阶段。</li></ol> <ul><li>dockerfile是软件的原材料</li> <li>docker镜像是软件的交付品</li> <li>docker容器可以认为是软件的运行态</li> <li>dockerfile面向开发，docker镜像成为交付标准，docker容器则涉及部署与运维，三者缺一不可，为docker体系的基石。</li> <li>dockerfile定义了进程需要的一切东西。 dockerfile涉及的内容包括 <strong>执行代码或是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程等等</strong></li></ul></li></ol></li> <li>dockerfile体系结构(<strong>保留字指令</strong>)
<ol><li>FROM
<ul><li>基础镜像，当前新镜像是基于哪个镜像的</li></ul></li> <li>MAINTAINER
<ul><li>镜像维护者的姓名和邮箱地址</li></ul></li> <li>RUN
<ul><li>容器构建时需要运行的命令</li></ul></li> <li>EXPOSE
<ul><li>当前容器对外暴露出的端口</li></ul></li> <li>WORKDIR
<ul><li>指定在创建容器后，终端默认登录的进来时的工作目录，落脚点</li></ul></li> <li>ENV
<ul><li>用来在构建镜像过程中设置环境变量</li></ul></li> <li>ADD</li></ol> <ul><li>将宿主机目录下的文件拷贝到镜像且ADD命令会自动处理URL和解压tar压缩包</li></ul> <ol start="8"><li>COPY
<ul><li>类似ADD，拷贝文件和目录到镜像中。</li> <li>两种写法
<ul><li>COPY src dest</li> <li>COPY[&quot;src&quot;,&quot;dest&quot;]</li></ul></li></ul></li> <li>VOLUME</li></ol> <ul><li>容器数据卷，用于保存和持久化数据</li></ul> <ol start="10"><li>CMD</li></ol> <ul><li><strong>指定一个容器启动时要运行的命令</strong> 注意和ENTRYPOINT概念区分</li> <li>dockerfile中可以有多个CMD指令，但只有最后一个生效，如果在执行docker run时有额外的命令，<strong>dockfile里面的最后一个CMD会被docker run 之后的命令替换</strong></li> <li>CMD 指令的格式和RUN相似，也是两种格式：
<ul><li>shell 格式 CMD &lt;命令&gt;</li> <li>exec 格式 CMD [&quot;可执行文件&quot;,&quot;参数1&quot;,&quot;参数2&quot;,....]
<ul><li>参数列表格式： CMD [&quot;参数1&quot;,&quot;参数2&quot;,....]，在指定了ENTRYPOINT指令后，用CMD指定具体的参数</li></ul></li></ul></li></ul> <ol start="11"><li>ENTRYPOINT</li></ol> <ul><li><strong>指定一个容器启动时要运行的命令</strong></li> <li>目的和CMD一样，都是在指定容器启动程序及参数。</li> <li>不会被覆盖，docker run 之后的参数命令会被传递给ENTRYPOINT,成为追加命令组合。</li> <li><strong>区别CMD和ENTRYPOINT案例</strong> <ul><li>制作CMD版可以查询ip信息的容器</li></ul> <div class="language- extra-class"><pre class="language-text"><code>FROM centos
RUN yum install -y curl
CMD [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ip.cn&quot;]
//再执行docker build
docker build -f /mydocker/Dockerfile3 -t myip .
</code></pre></div><ul><li>问题
<ul><li>-s 是显示ip地址</li> <li>-i 是为了显示http头信息</li> <li>但是直接在docker run 里面加 -i的话 会覆盖 -s 那个命令</li> <li>所以返回的结果会有错误。</li></ul></li> <li>为什么</li> <li>制作ENTRYPOINT版查询ip信息的容器</li></ul> <div class="language- extra-class"><pre class="language-text"><code>FROM centos
RUN yum install -y curl
ENTRYPOINT [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ip.cn&quot;]
//再执行docker build
docker build -f /mydocker/Dockerfile4 -t myip .
</code></pre></div><ul><li>此时在docker run里面加 -i 就会成为追加命令，不会覆盖 -s 命令。</li></ul></li></ul> <ol start="12"><li>ONBUILD</li></ol> <ul><li>类似一个触发器</li> <li>当构建一个被继承的dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发</li> <li>子镜像在构建时，会触发父镜像中的onbuild之后的 命令。</li></ul> <ol start="13"><li>小总结：</li></ol></li> <li>案例
<ul><li><strong>Base镜像(scratch)</strong>: docker hub中99%的镜像都是通过在base镜像中安装和配置需要的软件构建出来的</li> <li><strong>自定义镜像mycentos</strong> <ol><li><p>编写</p> <ul><li>hub默认centos镜像是什么情况</li> <li>准备编写dockerfile文件</li> <li>mycentos内容dockerfile</li></ul> <div class="language- extra-class"><pre class="language-text"><code>FROM centos
MAINTAINER yuechaor@gmail.com
ENV MYPATH /usr/local
WORKDIR $MYPATH
RUN yum -y install vim
RUN yum -y install net-tools
EXPOSE 80
CMD /bin/bash
</code></pre></div><ul><li>更改了路径落脚点</li> <li>安装了vim和net tool</li></ul></li> <li><p>构建</p> <ul><li>docker build -f /mydocker/Dockerfile2 -t mycentos: 1.0</li></ul></li> <li><p>运行</p></li> <li><p>列出镜像的变更历史</p> <ul><li>docker history imageID</li></ul></li></ol></li> <li><strong>自定义镜像tomcat</strong> <ol><li>mkdir -p /xxx/mydockerfile/tomcat9</li> <li>在上述目录下touch c.txt 目的是为了演示copy的命令。</li> <li>将jdk和tomcat安装的压缩包拷贝到该目录，目的是为了演示add命令</li> <li>在该目录下新建Dockerfile文件</li></ol> <div class="language- extra-class"><pre class="language-text"><code>FROM  centos
MAINTAINER ryc&lt;yuechao@gmail.com&gt;
#从host 拷贝到 容器/usr/local/
COPY c.txt /usr/local/cincontainer.txt
#添加java和tomcat压缩包到容器
ADD jdk-sxxxx.tar.gz /usr/local/
ADD tomcat-sxxxx.tar.gz /usr/local/
RUN yum -y install vim
WORKDIR $MYPATH
ENV MYPATH /usr/local
#配置环境变量
ENV JAVA_HOME /usr/local/jdk1.8.0.171
 ....
#容器运行时监听的端口
EXPOSE 8080
CMD /usr/local/apache-tomcat/bin/startup.sh &amp;&amp; tail -F /usr/loal/apache-tomcat/bin/logs/catalina.out
</code></pre></div><ol><li>构建</li></ol> <ul><li><strong>docker build . dot 怎么理解</strong></li> <li>当我们使用docker build来构建镜像时，这个构建过程是在daemon中进行的，而不是本地client，所以这个dot就是为了将构建所需的当前目录下的文件 以上下文build context的形式传送到daemon中，用于构建镜像。</li></ul> <ol start="2"><li>run</li></ol> <ul><li><blockquote><p>docker run -d -p 9999:8080 --name myTomcat9 -v /xxx/mydockerfile/tomcat9/test: /usr/local/apache-tomcat-9.0.8/webapps/test -v /xxx/mydockerfile/tomcat9/tomcat9logs: /usr/local/apache-tomcat-9.0.8/webapps/logs xxxtomcat9</p></blockquote></li></ul> <ol start="3"><li>验证</li> <li>结合前述的容器卷将测试的web服务test发布</li></ol> <ul><li>因此前创建了容器卷，所以我们可以直接在host中对应的test文件夹中部署apps或者查看日志，<strong>这样容器中对应的文件夹目录也会同步</strong></li></ul></li></ul></li></ol> <h2 id="docker常用安装"><a href="#docker常用安装" class="header-anchor">#</a> Docker常用安装</h2> <ol><li><p>总体步骤</p></li> <li><p>安装tomcat</p></li> <li><p>安装mysql</p> <ol><li>docker search mysql</li> <li>docker pull mysql：5.6</li></ol></li> <li><p>安装redis</p></li></ol> <h2 id="提交镜像到云端（阿里云）"><a href="#提交镜像到云端（阿里云）" class="header-anchor">#</a> 提交镜像到云端（阿里云）</h2> <ol><li>本地镜像发布到阿里云流程
<ol><li>镜像生成方法：docker commit -a yuechao -m &quot;new image&quot; imageID  newImageName:tag</li></ol></li> <li>将本地镜像推送到阿里云：阿里云开发者平台有相关步骤 如何设置和执行命令
<ol><li>本地镜像素材原型</li> <li>阿里云开发者平台</li> <li>创建仓库镜像</li> <li>将镜像推送到registry</li> <li>公有云可以查询到</li></ol></li> <li>之后就可以将阿里云上的镜像下载到本地使用了。</li></ol></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      createdAt : 2019-08-15
    </span> <span class="update-date" data-v-4e23451f>
      updatedAt : 2019-08-15
    </span></section> <section class="post-links" data-v-4e23451f><a href="/uNoteWhat/posts/2019/07/21/_78kengs.html" class="post-link" data-v-4e23451f>
      prevNote : 坑7坑8
    </a> <a href="/uNoteWhat/posts/2019/08/15/docker-advance.html" class="post-link" data-v-4e23451f>
      nextNote : Docker高级笔记
    </a></section></section> <!----></div></main> <aside class="aside" data-v-4dd605a1><div class="info-card main-div" data-v-9d847660 data-v-4dd605a1><div class="info-card-header" data-v-9d847660><img src="/uNoteWhat/img/avatar.jpeg" alt="PrintF" class="info-avatar" data-v-9d847660></div> <div class="info-card-body" data-v-9d847660><section class="info-nickname" data-v-9d847660>
      PrintF
    </section> <section class="info-desc" data-v-9d847660>Two Hours a day, Keeps Foolish Away</section> <section class="info-contact" data-v-9d847660><section data-v-9d847660><span title="Melbourne, AU" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>Melbourne, AU</title><use xlink:href="#icon-location" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          Melbourne, AU
        </span></span></section> <!----> <section data-v-9d847660><a href="mailto:yuechaor@gmail.com" title="yuechaor@gmail.com" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>yuechaor@gmail.com</title><use xlink:href="#icon-email" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          yuechaor@gmail.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-9d847660><section class="info-sns clearfix" data-v-9d847660><a href="https://github.com/yuechaor" target="_blank" class="sns-link" data-v-9d847660><span title="GitHub: yuechaor" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>GitHub: yuechaor</title><use xlink:href="#icon-github" data-v-9d847660 data-v-9d847660></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-4dd605a1><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>Table of Content</span> <div class="post-nav-toc"><ul><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#镜像和容器">镜像和容器</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#仓库repository">仓库repository</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#镜像，容器，仓库-相互关系">镜像，容器，仓库 相互关系</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#docker底层原理">docker底层原理</a><ul><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#docker是怎么工作的">docker是怎么工作的</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#为什么docker-比-vm-快">为什么docker 比 vm 快</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#docker-安装以及阿里云镜像加速配置">docker 安装以及阿里云镜像加速配置</a></li></ul></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#一般命令">一般命令</a><ul><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#帮助命令">帮助命令</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#镜像命令">镜像命令</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#容器命令">容器命令</a></li></ul></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#docker-镜像">docker 镜像</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#docker-容器数据卷">Docker 容器数据卷</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#dockerfile-解析">dockerfile 解析</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#docker常用安装">Docker常用安装</a></li><li><a href="/uNoteWhat/posts/2019/08/15/docker.html#提交镜像到云端（阿里云）">提交镜像到云端（阿里云）</a></li></ul></div></div> <!----></div></aside></div> <footer class="footer" data-v-17465a0e><p class="footer-sns-links" data-v-17465a0e><a href="https://github.com/yuechaor" target="_blank" class="sns-link" data-v-17465a0e><span title="GitHub: yuechaor" class="sns-icon" data-v-17465a0e data-v-17465a0e><svg class="icon" style="font-size:25px;" data-v-17465a0e data-v-17465a0e><title data-v-17465a0e data-v-17465a0e>GitHub: yuechaor</title><use xlink:href="#icon-github" data-v-17465a0e data-v-17465a0e></use></svg></span></a></p> <p class="footer-text" data-v-17465a0e><span data-v-17465a0e>Powered by </span> <a href="https://github.com/vuejs/vuepress" target="_blank" data-v-17465a0e>
      VuePress
    </a></p> <!----></footer></div><div class="global-ui"><!----><!----></div></div>
    <script src="/uNoteWhat/assets/js/app.58bd65f3.js" defer></script><script src="/uNoteWhat/assets/js/6.9f100392.js" defer></script><script src="/uNoteWhat/assets/js/18.76d03fcd.js" defer></script>
  </body>
</html>
